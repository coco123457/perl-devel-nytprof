/* vim: ts=2 sw=2 sts=0 noexpandtab:
 * ************************************************************************
 * This file is part of the Devel::NYTProf package.
 * Copyright 2008 Adam J. Kaplan, The New York Times Company.
 * Released under the same terms as Perl 5.8
 * See http://search.cpan.org/~akaplan/Devel-NYTProf for more information
 * ************************************************************************
 * $Id$
 * ************************************************************************
 */
#define PERL_NO_GET_CONTEXT		/* we want efficiency */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#if (PERL_VERSION < 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION < 8))
#undef PL_curcop
#define PL_curcop ((cxstack + cxstack_ix)->blk_oldcop)
#endif

#if !defined(OutCopFILE)
#define OutCopFILE CopFILE
#endif

#include <sys/time.h>
#include <stdio.h>
#ifdef HAS_STDIO_EXT_H
#include <stdio_ext.h>
#else
#warning "Not using stdio_ext.h. Add it to INCLUDE path and recompile with -DHAS_STDIO_EXT_H to use it."
#endif

#ifdef HASFPURGE
#define FPURGE(file) fpurge(file)
#elif defined(HAS_FPURGE)
#define FPURGE(file) _fpurge(file)
#elif defined(HAS__FPURGE)
#define FPURGE(file) __fpurge(file)
#else
#undef FPURGE
#warning "Not using _fpurge() -- There may be a preformance penalty."
#endif

/* Hash table definitions */
#define MAX_HASH_SIZE 512

typedef struct hash_entry {
	unsigned int id;
	void* next_entry;
	char* key;
	unsigned int key_len;
} Hash_entry;

typedef struct hash_table {
	Hash_entry** table;
	unsigned int size;
} Hash_table;

static Hash_table hashtable = {NULL, MAX_HASH_SIZE};
/* END Hash table definitions */

static char error[255];

/* constants */
static struct flock lockl;	/* initialised in init() */
static struct flock locku;	/* initialised in init() */

/* defaults */
static char* default_file = "nytprof.out";
static FILE* out;
static FILE* in;
static pid_t first_pid;
static pid_t last_pid;
static bool forkok = 0;
static bool usecputime = 0;
static bool profile_blocks = 0;

/* options and overrides */
static char PROF_output_file[MAXPATHLEN+1];
static char READER_input_file[MAXPATHLEN+1];
static bool PROF_use_stdout = 0;
static bool READER_use_stdin = 0;
static int trace_level = 0;

/* time tracking */
static struct tms start_ctime, end_ctime;
#ifdef _HAS_GETTIMEOFDAY
static struct timeval start_time, end_time;
#else
static int (*u2time)(pTHX_ UV *) = 0;
static UV start_utime[2], end_utime[2];
#endif
static unsigned int last_executed_line;
static unsigned int last_executed_file;
static unsigned int last_block_line;
static unsigned int last_sub_line;
static bool firstrun = 1;

/* reader module variables */
static HV* profile;
static unsigned int ticks_per_sec = 0; /* 0 forces error if not set */

/* prototypes */
void lock_file();
void unlock_file();
void print_header();
unsigned int get_file_id(char*, STRLEN, int);
void output_int(unsigned int);
void DB(pTHX);
void set_option(const char*);
void open_file(bool);
void init_runtime();
void init(pTHX);
void DEBUG_print_stats(pTHX);
HV *load_profile_data_from_stream();
AV *store_profile_line_entry(pTHX_ SV *rvav, unsigned int line_num, 
															double time, int count);

OP *pp_entersub_profiler(pTHX);
OP *(*pp_entersub_orig)(pTHX);
HV *sub_callers_hv;

/* macros for outputing profile data */
#define OUTPUT_PID() STMT_START { \
	fputc('P', out); output_int(getpid()); output_int(getppid()); \
} STMT_END


/***********************************
 * Devel::NYTProf Functions        *
 ***********************************/

/**
 * Set file lock
 */
void
lock_file() {
	if (fcntl(fileno(out), F_SETLKW, 	&lockl) == -1) {
		dTHX; /* should never happen */
		warn("fcntl F_SETLKW lock failed: %s\n", strerror(errno));
  }
}

/**
 * Release file lock
 */
void
unlock_file() {
	fflush(out);
	if (fcntl(fileno(out), F_SETLKW, 	&locku) == -1) {
		dTHX; /* should never happen */
		warn("fcntl F_SETLKW unlock failed: %s\n", strerror(errno));
  }
}

/**
 * output file header
 */
void
print_header(pTHX) {
	time_t basetime = PL_basetime;
	unsigned int ticks = (usecputime) ? CLOCKS_PER_SEC : 1000000;

	if (forkok) 
		lock_file();

	/* File header with "magic" string, with file major and minor version */
	fprintf(out, "NYTProf %d %d\n", 1, 0);
	/* Human readable comments and attributes follow
	 * comments start with '#', end with '\n', and are discarded
	 * attributes start with ':', a word, '=', then the value, then '\n'
	 */
	fprintf(out, "# Perl profile database. Generated by Devel::NYTProf on %s",
		ctime(&basetime)); /* uses \n from ctime to terminate line */

	/* XXX add options, $0, etc, but beware of embedded newlines */
	/* XXX would be good to adopt a proper charset & escaping for these */
	fprintf(out, ":%s=%d\n", "basetime", PL_basetime); /* $^T */
	fprintf(out, ":%s=%s\n", "xs_version", XS_VERSION);
	fprintf(out, ":%s=%u\n", "ticks_per_sec", ticks);

	OUTPUT_PID();

	fflush(out);

	if (forkok)
		unlock_file();
}

/**
 * An implementation of the djb2 hash function by Dan Bernstein.
 */
unsigned long
hash (char* _str, unsigned int len) {
	char* str = _str;
	unsigned long hash = 5381;

	while (len--) {
		hash = ((hash << 5) + hash) + *str++; /* hash * 33 + c */
	}
	return hash;
}

/**
 * Fetch/Store on hash table.  entry must always be defined. 
 * hash_op will find hash_entry in the hash table.  
 * hash_entry not in table, insert is false: returns NULL
 * hash_entry not in table, insert is true: inserts hash_entry and returns hash_entry
 * hash_entry in table, insert IGNORED: returns pointer to the actual hash entry
 */
char
hash_op (Hash_entry entry, Hash_entry** retval, bool insert) {
	static int next_fid = 1;	/* 0 is reserved */
	unsigned long h = hash(entry.key, entry.key_len) % hashtable.size;

	Hash_entry* found = hashtable.table[h];
	while(NULL != found) {

		if (found->key_len == entry.key_len && 
				0 == strncmp(found->key, entry.key, entry.key_len)) {
			*retval = found;
			return 0;
		}

		if(NULL == (Hash_entry*)found->next_entry) {
			if (insert) {

				Hash_entry* e = (Hash_entry*)safemalloc(sizeof(Hash_entry));
				e->id = next_fid++;
				e->next_entry = NULL;
				e->key_len = entry.key_len;
				e->key = (char*)safemalloc(sizeof(char) * e->key_len + 1);
				e->key[e->key_len] = '\0';
				strncpy(e->key, entry.key, e->key_len);

				*retval = found->next_entry = e;
				return 1;
			} else {
				*retval = NULL;
				return -1;
			}
		}
		found = (Hash_entry*)found->next_entry;
	}

	if (insert) {
		Hash_entry* e = (Hash_entry*)safemalloc(sizeof(Hash_entry));
		e->id = next_fid++;
		e->next_entry = NULL;
		e->key_len = entry.key_len;
		e->key = (char*)safemalloc(sizeof(char) * e->key_len + 1);
		e->key[e->key_len] = '\0';
		strncpy(e->key, entry.key, e->key_len);

		*retval =	hashtable.table[h] = e;
		return 1;
	}

	retval = NULL;
	return -1;
}

/**
 * Return a unique persistent id number for a file.
 * If file name has not been seen before
 * then, if create_new is false it returns 0 othwise it
 * assigns a new id and outputs the file and id to the stream.
 * If the file name is a synthetic name for an eval then
 * get_file_id recurses to process the 'embedded' file name first.
 */
unsigned int
get_file_id(char* file_name, STRLEN file_name_len, int create_new) {

	dTHX;
	Hash_entry entry, *found;

	/* AutoLoader adds some information to Perl's internal file name that we have
	   to remove or else the file path will be borked */
	if (')' == file_name[file_name_len - 1]) {
		char* new_end = strstr(file_name, " (autosplit ");
		if (new_end)
			file_name_len = new_end - file_name;
	}
	entry.key = file_name;
	entry.key_len = file_name_len;

	if(1 == hash_op(entry, &found, create_new)) {	/* inserted new entry */
	  /* if this is a synthetic filename for an 'eval'
		 * ie "(eval 42)[/some/filename.pl:line]"
		 * then ensure we've already generated an id for the underlying filename
		 */
		unsigned int eval_fid = 0;
		unsigned int eval_line_num = 0;
		if ('(' == file_name[0] && ']' == file_name[file_name_len-1]) {
			char *start = strchr(file_name, '[');
			char *colon = ":";
			/* can't use strchr here (not nul terminated) so use rninstr */
			char *end = rninstr(file_name, file_name+file_name_len-1, colon, colon+1);

			if (!start || !end || start > end) {
				warn("Unsupported filename syntax '%s'", file_name);
				return 0;
			}
			++start; /* move past [ */
			eval_fid = get_file_id(start, end - start, create_new);	/* recurse */
			eval_line_num = atoi(end+1);
		}

		if (forkok)
			lock_file();

		fputc('@', out);
		output_int(found->id);
		output_int(eval_fid);
		output_int(eval_line_num);
		while (file_name_len--)
			fputc(*file_name++, out);
		fputc('\n', out);

		if (forkok)
			unlock_file();

		if (trace_level) {
			if (eval_fid)
				warn("New fid %2u: %.*s (eval fid %u line %u)\n",
					found->id, found->key_len, found->key, eval_fid, eval_line_num);
		  else
				warn("New fid %2u: %.*s\n",
					found->id, found->key_len, found->key);
		}
	}
	else if (!found) {
		return 0;
  }
  else if (trace_level >= 4) {
		warn("fid %d: %.*s\n", found->id, found->key_len, found->key);
	}

	return found->id;
}

/**
 * Output an integer in bytes. That is, output the number in binary, using the
 * least number of bytes possible.  All numbers are positive. Use sign slot as
 * a marker
 */
void output_int(unsigned int i) {

	/* general case. handles all integers */
	if (i < 0x80) { /* < 8 bits */
		fputc( (char)i, out);
	}
	else if (i < 0x4000) { /* < 15 bits */
		fputc( (char)((i >> 8) | 0x80), out);
		fputc( (char)i, out);
	}
	else if (i < 0x200000) { /* < 22 bits */
		fputc( (char)((i >> 16) | 0xC0), out);
		fputc( (char)(i >> 8), out);
		fputc( (char)i, out);
	}
	else if (i < 0x10000000)  { /* 32 bits */
		fputc( (char)((i >> 24) | 0xE0), out);
		fputc( (char)(i >> 16), out);
		fputc( (char)(i >> 8), out);
		fputc( (char)i, out);
	}
	else {	/* need all the bytes. */
		fputc( 0xFF, out);
		fputc( (char)(i >> 24), out);
		fputc( (char)(i >> 16), out);
		fputc( (char)(i >> 8), out);
		fputc( (char)i, out);
	}
}


static char* block_type[] = {
    "NULL",
    "SUB",
    "EVAL",
    "LOOP",
    "SUBST",
    "BLOCK",
};


/* based on S_dopoptosub_at() from perl pp_ctl.c */
static int
dopopcx_at(pTHX_ PERL_CONTEXT *cxstk, I32 startingblock, UV stop_at)
{
    I32 i;
    register PERL_CONTEXT *cx;
    for (i = startingblock; i >= 0; i--) {
        cx = &cxstk[i];
        UV type_bit = 1 << CxTYPE(cx);
        if (type_bit & stop_at)
            return i;
    }
    return i; /* == -1 */
}


static COP *
start_cop_of_context(pTHX_ PERL_CONTEXT *cx) {
    OP *start_op, *o;
    int type;

    switch (CxTYPE(cx)) {
    case CXt_EVAL:
        start_op = (OP*)cx->blk_oldcop;
        break;
    case CXt_FORMAT:
        start_op = CvSTART(cx->blk_sub.cv);
        break;
    case CXt_SUB:
        start_op = CvSTART(cx->blk_sub.cv);
        break;
    case CXt_LOOP:
#if (PERL_VERSION < 10)
        start_op = cx->blk_loop.redo_op;
#else
        start_op = cx->blk_loop.my_op->op_redoop;
#endif
        break;
    case CXt_BLOCK:
				/* this will be NULL for the top-level 'main' block */
        start_op = (OP*)cx->blk_oldcop;
        break;
    case CXt_SUBST:			/* FALLTHRU */
    case CXt_NULL:			/* FALLTHRU */
		default:
        start_op = NULL;
        break;
    }
    if (!start_op) {
        if (trace_level >= 4)
            warn("\tstart_cop_of_context: can't find start of %s\n", 
            			block_type[CxTYPE(cx)]);
        return NULL;
    }
    /* find next cop from OP */
		o = start_op;
    while ( o && (type = (o->op_type) ? o->op_type : o->op_targ) ) {
        if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE) {
				  if (trace_level >= 4)
						warn("\tstart_cop_of_context %s is %s line %d of %s\n",
							block_type[CxTYPE(cx)], OP_NAME(o), CopLINE((COP*)o), 
							OutCopFILE((COP*)o));
					return (COP*)o;
				}
        /* should never get here? */
        if (1 || trace_level)
            warn("\tstart_cop_of_context %s op '%s' isn't a cop", 
            			block_type[CxTYPE(cx)], OP_NAME(o));
        if (trace_level >= 4)
            do_op_dump(1, PerlIO_stderr(), o);
        o = o->op_next;
    }
    if (trace_level >= 3) {
			warn("\tstart_cop_of_context: can't find next cop for %s line %d\n",
					block_type[CxTYPE(cx)], CopLINE(PL_curcop));
			do_op_dump(1, PerlIO_stderr(), start_op);
		}
    return NULL;
}

static PERL_CONTEXT *
visit_contexts(pTHX_ UV stop_at, int (*callback)(pTHX_ PERL_CONTEXT *cx, 
								UV *stop_at_ptr)) 
{
    dSP;
    /* modelled on pp_caller() in pp_ctl.c */
    register I32 cxix = cxstack_ix;
    register PERL_CONTEXT *cx = NULL;
    register PERL_CONTEXT *ccstack = cxstack;
    PERL_SI *top_si = PL_curstackinfo;

    if (trace_level >= 4)
        warn("visit_contexts: \n");

    while (1) {
        /* we may be in a higher stacklevel, so dig down deeper */
				/* XXX so we'll miss code in sort blocks and signals?		*/
				/* callback should perhaps be moved to dopopcx_at */
        while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {
            if (trace_level >= 3)
							warn("Not on main stack (type %d); digging top_si %p->%p, ccstack %p->%p\n",
										top_si, top_si->si_prev, ccstack, top_si->si_cxstack);
            top_si  = top_si->si_prev;
            ccstack = top_si->si_cxstack;
            cxix = dopopcx_at(aTHX_ ccstack, top_si->si_cxix, stop_at);
        }
        if (cxix < 0 || (cxix == 0 && !top_si->si_prev)) {
						/* cxix==0 && !top_si->si_prev => top-level BLOCK */
						if (trace_level >= 4)
								warn("visit_contexts: reached top of context stack\n");
						return NULL;
        }
        cx = &ccstack[cxix];
        if (trace_level >= 4)
					warn("visit_context: %s cxix %d (si_prev %p)\n",
							block_type[CxTYPE(cx)], cxix, top_si->si_prev);
				if (callback(aTHX_ cx, &stop_at))
					return cx;
        /* no joy, look further */
        cxix = dopopcx_at(aTHX_ ccstack, cxix - 1, stop_at);
    }
    return NULL; /* not reached */
}

int
_check_context(pTHX_ PERL_CONTEXT *cx, UV *stop_at_ptr)
{
		COP *near_cop;

		if (CxTYPE(cx) == CXt_SUB) {
				if (PL_debstash && CvSTASH(cx->blk_sub.cv) == PL_debstash)
					return 0; /* skip subs in DB package */
				if (trace_level >= 4) {
					GV *sv = CvGV(cx->blk_sub.cv);
					warn("\t%s %s\n", block_type[CxTYPE(cx)], (sv) ? GvNAME(sv) : "");
					if (trace_level >= 9)
						sv_dump((SV*)cx->blk_sub.cv);
				}
				near_cop = start_cop_of_context(aTHX_ cx);
				/* don't use the cop if it's in a different file */
				if (OutCopFILE(near_cop) != OutCopFILE(PL_curcop)) {
					return 1; /* stop looking, leave last_sub_line unset */
				}

				last_sub_line = CopLINE(near_cop);
				/* treat sub as a block if we've not found a block yet */
				if (!last_block_line)
						last_block_line = last_sub_line;
				return 1;		/* stop looking */
		}

	/* NULL, EVAL, LOOP, SUBST, BLOCK context */
	if (trace_level >= 4)
		warn("\t%s\n", block_type[CxTYPE(cx)]);
	/* if we've got a block line, skip this context and keep looking for a sub */
	if (last_block_line)
		return 0;
	/* if we can't get a line number for this context, skip it */
	if ((near_cop = start_cop_of_context(aTHX_ cx)) == NULL)
		return 0;
	/* if this context is in a different file... */
	if (OutCopFILE(near_cop) != OutCopFILE(PL_curcop)) {
		/* if we started in a string eval ... */
		if ('(' == *OutCopFILE(PL_curcop)) {
			last_block_line = last_sub_line = 1;
			return 1;
		}
		/* shouldn't happen! */
		if (trace_level >= 3)
			warn("%s in different file (%s, %s)", block_type[CxTYPE(cx)], 
						OutCopFILE(near_cop), OutCopFILE(PL_curcop));
		return 1; /* stop looking */
	}
	last_block_line = CopLINE(near_cop);
	return 0;
}

/**
 * PerlDB implementation. Called before each breakable statement
 */
void
DB(pTHX) {
	IV line;
	char *file;
	unsigned int elapsed;
	COP *cop = PL_curcop;

	if (usecputime) {
		times(&end_ctime);
		elapsed = end_ctime.tms_utime - start_ctime.tms_utime
						+ end_ctime.tms_stime - start_ctime.tms_stime;
	} else {
#ifdef _HAS_GETTIMEOFDAY
		gettimeofday(&end_time, NULL);
		elapsed = (end_time.tv_sec - start_time.tv_sec) * 1000000
						+ end_time.tv_usec - start_time.tv_usec;
#else
		(*u2time)(aTHX_ end_utime);
		elapsed = (end_utime[0] - start_utime[0]) * 1000000
						+ end_utime[1] - start_utime[1];
#endif
	}

	/* out should never be NULL, but perl sometimes falls into DB() AFTER
	   it calls _finish() (which is ONLY used in END {...}. Strange!) */
	if (!out)
		return;

	if (!firstrun) { 
		if (forkok)
			lock_file();
		if (forkok) {
			if (last_pid != getpid()) { /* handle forks */
				if (trace_level >= 1)
					warn("New pid %d (was %d)\n", getpid(), last_pid);
				last_pid = getpid();
#ifdef FPURGE
				FPURGE(out);
#endif
				OUTPUT_PID();
			}
		}

		fputc( (profile_blocks) ? '*' : '+', out);
		output_int(elapsed);
		output_int(last_executed_file);
		output_int(last_executed_line);
    if (profile_blocks) {
			output_int(last_block_line);
			output_int(last_sub_line);
		}
		if (trace_level >= 3)
			warn("Wrote %d:%-4d %2u ticks (%u, %u)\n", last_executed_file, 
						last_executed_line, elapsed, last_block_line, last_sub_line);

		if (forkok) {
			unlock_file();
		}
	} else {
		firstrun = 0;
	}

	file = OutCopFILE(cop);
	/* XXX temporary restriction until we get better support for forking  */
	/* if we've forked then we no longer allow new fids to be generated   */
	last_executed_file = get_file_id(file, strlen(file), (last_pid == first_pid));
	last_executed_line = CopLINE(cop);

  if (profile_blocks) {
		if (trace_level >= 4)
			warn("\tlooking for block and sub lines for %u:%u\n", last_executed_file, 
						last_executed_line);

		last_block_line = 0;
		last_sub_line   = 0;
		visit_contexts(aTHX_ ~0, &_check_context);
		/* if we didn't find block or sub scopes then use current line */
		if (!last_block_line) last_block_line = last_executed_line;
		if (!last_sub_line)   last_sub_line   = last_executed_line;
	}

	if (usecputime) {
		times(&start_ctime);
	} else {
#ifdef _HAS_GETTIMEOFDAY
		gettimeofday(&start_time, NULL);
#else
		start_utime[2];
		(*u2time)(aTHX_ start_utime);
#endif
	}
}

/**
 * Sets or toggles the option specified by 'option'. 
 */
void
set_option(const char* option) {
	if(0 == strncmp(option, "use_stdout", 10)) {
		if (trace_level) warn("# Using standard out for output.\n");
		PROF_use_stdout = 1;
	} else if(0 == strncmp(option, "in=", 3)) {
		strncpy(READER_input_file, &option[3], MAXPATHLEN);
		if (trace_level) warn("# Using  %s for input.\n", READER_input_file);
	} else if(0 == strncmp(option, "out=", 4)) {
		strncpy(PROF_output_file, &option[4], MAXPATHLEN);
		if (trace_level) warn("# Using %s for output.\n", PROF_output_file);
	} else if(0 == strncmp(option, "use_stdin", 9)) {
		if (trace_level) warn("# Using stanard in for input.\n");
		READER_use_stdin = 1;
	} else if(0 == strncmp(option, "allowfork", 9)) {
		if (trace_level) warn("# Fork mode: ENABLED.\n");
		forkok = 1;
	} else if(0 == strncmp(option, "usecputime", 10)) {
		if (trace_level) warn("# Using cpu time.\n");
		usecputime = 1;
	} else if(0 == strncmp(option, "blocks", 6)) {
		if (trace_level) warn("# profiling blocks.\n");
		profile_blocks = 1;
	} else if(0 == strncmp(option, "trace=", 6)) {
		trace_level = atoi(option+6);
		if (trace_level) warn("# trace set to %d.\n", trace_level);
	} else {
		warn("Unknown option: %s\n", option);
	}
}

/**
 * Open the output file. This is encapsulated because the code can be reused
 * without the environment parsing overhead after each fork.
 */
void
open_file(bool forked) {

  char *filename;
	char *mode = (forked) ? "ab" : "wb";
	int fd;
	if (PROF_use_stdout) {										/* output to stdout */
		fd = dup(STDOUT_FILENO);
		if (-1 == fd)
			perror("Unable to dup stdout");
		filename = NULL;
	}
	else if (0 != strlen(PROF_output_file)) {	/* output to user provided file */
		filename = PROF_output_file;
	} else {																	/* output to default output file */
		filename = default_file;
	}
	if (trace_level)
			warn("Opening %s (%s)\n", (filename) ? filename : "STDOUT", mode);

	out = (filename) ? fopen(filename, mode) : fdopen(fd, mode);
}


/************************************
 * Sub caller tracking
 ************************************/

void
intercept_opcodes(pTHX) {
	sub_callers_hv = newHV();
	pp_entersub_orig = PL_ppaddr[OP_ENTERSUB];
	PL_ppaddr[OP_ENTERSUB] = pp_entersub_profiler;
}

OP *
pp_entersub_profiler(pTHX) {
	OP *op;
	COP *prev_cop = NULL;
	OP *next_op = PL_op->op_next; /* op to execute after sub returns */

	if (cxstack_ix >= 0)	/* dodge wierdness */
		prev_cop = PL_curcop;

	/*
	 * for normal subs pp_entersub enters the sub
	 * and returns the first op *within* the sub (typically a dbstate).
	 * for XS subs pp_entersub executes the entire sub
	 * and returning the op *after* the sub (PL_op->op_next)
	 */
	op = pp_entersub_orig(aTHX);

	/* have entered a sub and we're profiling */
	if (op != next_op && prev_cop && SvTRUE(PL_DBsingle)) {

		/* get line, file, and fid for statement *before* the call */
		char *file = OutCopFILE(PL_curcop);
		int line = CopLINE(PL_curcop);
		unsigned int fid = get_file_id(file, strlen(file), 1);
		char fid_line_key[50];
		sprintf(fid_line_key, "%u:%d", fid, line);

		/* get name of sub we've just entered */
		GV *cvgv = CvGV(cxstack[cxstack_ix].blk_sub.cv);
		SV *subname_sv = newSV(0);

		if (0) fprintf(stderr, "PL_curcop %p %d %p (op_next %p)\n", cxstack, 
										cxstack_ix, PL_curcop, next_op);

		if (isGV(cvgv)) {
			gv_efullname3(subname_sv, cvgv, Nullch);
		}
		else {
			warn("unknown blk_sub.cv '%s'",SvPV_nolen((SV*)cvgv));
			sv_setpvn(subname_sv, "(unknown)",9);
		}
		if (trace_level >= 3)
			fprintf(stderr, "fid %d:%d called %s (%s)\n", fid, line, 
							SvPV_nolen(subname_sv), OP_NAME(op));

		/* { subname => { "fid:line" => count } } */
		SV *sv = *hv_fetch(sub_callers_hv, SvPV_nolen(subname_sv), 
												SvCUR(subname_sv), 1);
		if (!SvROK(sv)) /* autoviv */
			sv_setsv(sv, newRV_noinc((SV*)newHV()));
		sv = *hv_fetch((HV*)SvRV(sv), fid_line_key, strlen(fid_line_key), 1);
		sv_inc(sv);
	}
	return op;
}


/************************************
 * Shared Reader,NYTProf Functions  *
 ************************************/

/**
 * Populate runtime values from environment, the running script or use defaults
 */
void
init_runtime(const char* file) {

	/* Runtime configuration
	   Environment vars have lower priority */
	char* sysenv = getenv("NYTPROF");
	if (NULL != sysenv && strlen(sysenv) > 0) {
		char env[500];
		char* result = NULL;

		strcpy(env, sysenv);
		result = strtok(env, ":");

		if (NULL == result) {
			set_option(env);
		}
		while(result != NULL) {
			set_option(result);
			result = strtok(NULL, ":");
		}
	}

	/* a file name passed to load_profile_data_from_file(...) has the highest 
	 * priority
	 */
	if (NULL != file) {
		READER_use_stdin = 0;
		PROF_use_stdout = 0;
		strncpy(READER_input_file, file, strlen(file));
		strncpy(PROF_output_file, file, strlen(file));
	}
}

/* Initial setup */
void
init_profiler(pTHX) {
	HV* hash = get_hv("DB::sub", 0);

	/* initialize flock structs portably */
	lockl.l_type   = F_WRLCK;
	lockl.l_whence = SEEK_SET;
	locku.l_type   = F_UNLCK;
	locku.l_whence = SEEK_SET;

	/* Save the process id early. We can monitor it to detect forks that affect 
		 output buffering.
		 NOTE: don't fork before calling the xsloader obviously! */
	last_pid = first_pid = getpid();

	if (trace_level)
		warn("NYTProf init pid %d\n", last_pid);

	if (hash == NULL) {
		croak("Debug symbols not found. Is perl in debug mode?");
	}

	/* create file id mapping hash */
	unsigned int hashtable_memwidth = sizeof(Hash_entry*) * hashtable.size;
	hashtable.table = (Hash_entry**)safemalloc(hashtable_memwidth);
	memset(hashtable.table, 0, hashtable_memwidth);
	
	init_runtime(NULL);

	open_file(0);
	if (out == NULL) {
		croak("Failed to open output: %s", strerror(errno));
	}

	print_header(aTHX);

	intercept_opcodes(aTHX);

	/* seed first run time */
	if (usecputime) {
		times(&start_ctime);
	} else {
#ifdef _HAS_GETTIMEOFDAY
		gettimeofday(&start_time, NULL);
#else
		SV **svp = hv_fetch(PL_modglobal, "Time::U2time", 12, 0);
		if (!svp || !SvIOK(*svp)) croak("Time::HiRes is required");
		u2time = INT2PTR(int(*)(pTHX_ UV*), SvIV(*svp));
		(*u2time)(aTHX_ start_utime);
#endif
	}
}

/************************************
 * Devel::NYTProf::Reader Functions *
 ************************************/

void
add_entry(pTHX_ AV *dest_av, unsigned int file_num, unsigned int line_num,			
					double time, unsigned int eval_file_num, unsigned int eval_line_num) 
{
	bool eval_mode = eval_file_num;

  /* get ref to array of per-line data */
	SV *line_time_rvav = *av_fetch(dest_av, 
													(eval_line_num) ? eval_file_num : file_num, 1);

	if (!SvROK(line_time_rvav))		/* autoviv */
			sv_setsv(line_time_rvav, newRV_noinc((SV*)newAV()));

  /* times for string evals are accumulated within the line the eval is on */
  if (!eval_line_num) {
		store_profile_line_entry(aTHX_ line_time_rvav, line_num, time, 1);
	}
	else {
		AV *av = store_profile_line_entry(aTHX_ line_time_rvav, eval_line_num,
																			0, 0);
		SV *eval_line_time_rvav = *av_fetch(av, 2, 1);
		if (!SvROK(eval_line_time_rvav))		/* autoviv */
				sv_setsv(eval_line_time_rvav, newRV_noinc((SV*)newAV()));

		store_profile_line_entry(aTHX_ eval_line_time_rvav, line_num, time, 1);
	}
}


AV *
store_profile_line_entry(pTHX_ SV *rvav, unsigned int line_num, double time, 
													int count)
{
	SV *time_rvav = *av_fetch((AV*)SvRV(rvav), line_num, 1);
	AV *line_av;
	if (!SvROK(time_rvav)) {		  /* autoviv */
		line_av = newAV();
		sv_setsv(time_rvav, newRV_noinc((SV*)line_av));
		av_store(line_av, 0, newSVnv(time));
		av_store(line_av, 1, newSViv(count));
	}
	else {
		line_av = (AV*)SvRV(time_rvav);
		SV *time_sv = *av_fetch(line_av, 0, 1);
		sv_setnv(time_sv, time + SvNV(time_sv));
		if (count) {
		  SV *sv = *av_fetch(line_av, 1, 1);
			(count == 1) ? sv_inc(sv) : sv_setiv(sv, time + SvIV(sv));
		}
	}
	return line_av;
}


void
write_sub_line_ranges(pTHX, int fids_only) {
	char *sub_name;
	I32 sub_name_len;
	SV *file_lines_sv;
	HV *hv = GvHV(PL_DBsub);

	lock_file();
	hv_iterinit(hv);
	while (NULL != (file_lines_sv = hv_iternextsv(hv, &sub_name, &sub_name_len))) 
	{
		char *file_lines = SvPV_nolen(file_lines_sv); /* "filename:first-last" */
		char *first = strrchr(file_lines, ':');
		char *last = (first) ? strchr(first, '-') : NULL;
		unsigned int fid;
		UV first_line, last_line;

		if (!first || !last || !grok_number(first+1, last-first-1, &first_line)) {
			warn("Can't parse %%DB::sub entry for %s '%s'\n", sub_name, file_lines);
			continue;
		} 
		last_line = atoi(++last);

		if (!first_line && !last_line && strstr(sub_name, "::BEGIN"))
			continue;	/* no point writing these */

		fid = get_file_id(file_lines, first - file_lines, 0);
		if (!fid)  /* no point in writing subs in files we've not profiled */
			continue;
		if (fids_only)  /* caller just wants fids assigned */
			continue;

		if (trace_level >= 2)
			warn("Sub %s fid %u lines %u..%u\n", sub_name, fid, first_line, 
																					last_line);

		fputc('s', out);
		output_int(fid);
		output_int(first_line);
		output_int(last_line);
		fputs(sub_name, out);
		fputc('\n', out);
	}
	unlock_file();
}


void
write_sub_callers(pTHX) {
	char *sub_name;
	I32 sub_name_len;
	SV *fid_line_rvhv;

	if (!sub_callers_hv)
		return;

	lock_file();
	hv_iterinit(sub_callers_hv);
	while (NULL != (fid_line_rvhv = hv_iternextsv(sub_callers_hv, &sub_name, 
									&sub_name_len))) 
	{
		HV *fid_lines_hv = (HV*)SvRV(fid_line_rvhv);
		char *fid_line_string;
		I32 fid_line_len;
		SV *sv;

		hv_iterinit(fid_lines_hv);
		while (NULL != (sv = hv_iternextsv(fid_lines_hv, &fid_line_string,
										&fid_line_len))) 
		{
			IV count = SvIV(sv);
			unsigned int fid = 0;
			unsigned int line = 0;
			sscanf(fid_line_string, "%u:%u", &fid, &line);
			if (trace_level >= 3)
				warn("%s called by %u:%u: count %d\n", sub_name, fid, line, count);

			fputc('c', out);
			output_int(fid);
			output_int(line);
			output_int(count);
			fputs(sub_name, out);
			fputc('\n', out);
		}
	}
	unlock_file();
}


/**
 * Read an integer by decompressing the next 1 to 4 bytes of binary into a 32-
 * bit integer. See output_int() for the compression details.
 */
unsigned int
read_int() {

	static unsigned char d;
	static unsigned int newint;

	d = fgetc(in);
	if (d < 0x80) { /* 7 bits */
		newint = d;
		return newint;
	}
	else if (d < 0xC0) { /* 14 bits */
		newint = d & 0x7F;
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} 
	else if (d < 0xE0) { /* 21 bits */
		newint = d & 0x1F;
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} 
	else if (d < 0xFF) { /* 28 bits */
		newint = d & 0xF;
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} 
	else if (d == 0xFF) { /* 32 bits */
		newint = (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} else {
		dTHX;
		croak("File format error. Unrecognized marker");
	}
}

/**
 * Process a profile output file and return the results in a hash like
 * { fid_filename  => [ filename, filename, ... ], # index by [fid]
 *   fid_line_time  => [ [...],[...],..  ] # index by [fid][line]
 * }
 * The value of each [fid][line] is an array ref containing:
 * [ number of calls, total time spent ]
 * lines containing string evals also get an extra element
 * [ number of calls, total time spent, [...] ]
 * which is an reference to an array containing the [calls,time]
 * data for each line of the string eval.
 */
HV*
load_profile_data_from_stream() {
	dTHX; 
	int file_major, file_minor;

	unsigned long input_line = 0L;
	unsigned int file_num;
	unsigned int line_num;
	unsigned int ticks;
	char text[MAXPATHLEN*2];
	int c; /* for while loop */
	HV *profile_hv;
	HV *live_pids_hv = newHV();
	HV *attr_hv = newHV();
	AV* fid_filename_av = newAV();
	AV* fid_line_time_av = newAV();
	AV* fid_block_time_av = NULL;
	AV* fid_sub_time_av = NULL;
	HV* sub_fid_lines_hv = NULL;
	HV* sub_callers_hv = NULL;

	av_extend(fid_filename_av, 64);  /* grow it up front. */
	av_extend(fid_line_time_av, 64);

	if (2 != fscanf(in, "NYTProf %d %d\n", &file_major, &file_minor)) {
		croak("Profile format error while parsing header");
	}
	if (file_major != 1)
		croak("Profile format version %d.%d not supported", file_major, file_minor);

	while (EOF != (c = fgetc(in))) {
		input_line++;
		if (trace_level >= 4)
			warn("Token %lu is %d ('%c')\n", input_line, c, c);

		switch (c) {
			case '*':			/*FALLTHRU*/
			case '+':
			{
				SV *filename_sv;
				double seconds;
				unsigned int eval_file_num = 0;
				unsigned int eval_line_num = 0;

				ticks    = read_int();
				seconds  = (double)ticks / ticks_per_sec;
				file_num = read_int();
				line_num = read_int();

				filename_sv = *av_fetch(fid_filename_av, file_num, 1);
				if (!SvOK(filename_sv)) {
				  warn("File id %u used but not defined", file_num);
				}
				else if (SvROK(filename_sv)) {	/* is an eval */
					AV *av = (AV*)SvRV(filename_sv);
					eval_file_num = SvUV(*av_fetch(av,1,1));
					eval_line_num = SvUV(*av_fetch(av,2,1));
					file_num = eval_file_num;
				}

				add_entry(aTHX_ fid_line_time_av, file_num, line_num,
						seconds, eval_file_num, eval_line_num);
				if (trace_level >= 3)
						warn("Read %d:%-4d %2u ticks\n", file_num, line_num, ticks);

				if (c == '*') {
					unsigned int block_line_num = read_int();
					unsigned int sub_line_num   = read_int();

					if (!fid_block_time_av)
						fid_block_time_av = newAV();
					add_entry(aTHX_ fid_block_time_av, file_num, block_line_num,
							seconds, eval_file_num, eval_line_num);

					if (!fid_sub_time_av)
						fid_sub_time_av = newAV();
					add_entry(aTHX_ fid_sub_time_av, file_num, sub_line_num,
							seconds, eval_file_num, eval_line_num);

					if (trace_level >= 3)
							warn("\tblock %u, sub %u\n", block_line_num, sub_line_num);
				}

				break;
			}

			case '@':
			{
				SV *fid_info_sv;
				unsigned int eval_file_num;
				unsigned int eval_line_num;

				file_num = read_int();
				eval_file_num = read_int();
				eval_line_num = read_int();

				if (NULL == fgets(text, sizeof(text), in))
					/* probably EOF */
					croak("Profile format error while reading fid declaration"); 
				if (trace_level) {
						if (eval_file_num)
							warn("Fid %2u is %.*s (eval fid %u line %u)\n",
									file_num, strlen(text)-1, text, eval_file_num, eval_line_num);
						else
							warn("Fid %2u is %.*s\n",
									file_num, strlen(text)-1, text);
				}

				if (av_exists(fid_filename_av, file_num)
						&& strnNE(SvPV_nolen(AvARRAY(fid_filename_av)[file_num]), text, 
											strlen(text)-1)
				) {
					warn("File id %d redefined from %s to %s", file_num,
								SvPV_nolen(AvARRAY(fid_filename_av)[file_num]), text);
				}

				fid_info_sv = newSVpvn(text, strlen(text)-1); /* drop newline */
				if (eval_line_num) {
					/* change fid_info_sv to ref to array of 
					 * [ name, eval_file_num, eval_line_num ] 
					 */
					AV *av = newAV();
					av_store(av, 0, fid_info_sv);
					av_store(av, 1, newSVuv(eval_file_num));
					av_store(av, 2, newSVuv(eval_line_num));
				  fid_info_sv = newRV_noinc((SV*)av);
				}

				av_store(fid_filename_av, file_num, fid_info_sv);
				break;
			}

			case 's':	/* subroutine file line range */
			{
				SV *sv;
				AV *av;
				unsigned int fid        = read_int();
				unsigned int first_line = read_int();
				unsigned int last_line  = read_int();
				if (NULL == fgets(text, sizeof(text), in))
					croak("Profile format error in sub line range"); /* probably EOF */
				if (trace_level >= 3)
				    warn("Sub %.*s fid %u lines %u..%u\n",
							strlen(text)-1, text, fid, first_line, last_line);
				if (!sub_fid_lines_hv)
					sub_fid_lines_hv = newHV();
				/* { 'pkg::sub' => [ fid, first_line, last_line ], ... } */
				sv = *hv_fetch(sub_fid_lines_hv, text, strlen(text)-1, 1);
				if (!SvROK(sv))		/* autoviv */
						sv_setsv(sv, newRV_noinc((SV*)newAV()));
				av = (AV*)SvRV(sv);
				av_store(av, 0, newSVuv(fid));
				av_store(av, 1, newSVuv(first_line));
				av_store(av, 2, newSVuv(last_line));
				break;
			}

			case 'c':	/* sub callers */
			{
				SV *sv;
				unsigned int fid   = read_int();
				unsigned int line  = read_int();
				unsigned int count = read_int();
				if (NULL == fgets(text, sizeof(text), in))
					croak("Profile format error in sub line range"); /* probably EOF */

				if (trace_level >= 3)
				    warn("Sub %.*s called by fid %u line %u: count %d\n",
							strlen(text)-1, text, fid, line, count);

				if (!sub_callers_hv)
					sub_callers_hv = newHV();
				/* { 'pkg::sub' => { fid => { line => count } } } */
				sv = *hv_fetch(sub_callers_hv, text, strlen(text)-1, 1);
				if (!SvROK(sv))		/* autoviv */
						sv_setsv(sv, newRV_noinc((SV*)newHV()));

				sprintf(text, "%u", fid);
				sv = *hv_fetch((HV*)SvRV(sv), text, strlen(text), 1);
				if (!SvROK(sv)) /* autoviv */
					sv_setsv(sv, newRV_noinc((SV*)newHV()));

				sprintf(text, "%u", line);
				sv = *hv_fetch((HV*)SvRV(sv), text, strlen(text), 1);

				sv_setuv(sv, count);
				break;
			}

			case 'P':
			{
				unsigned int pid  = read_int();
				unsigned int ppid = read_int();
				sprintf(text, "%d", pid);
				hv_store(live_pids_hv, text, strlen(text), newSVuv(ppid), 0);
				if (trace_level)
					warn("Start of profile data for pid %s (ppid %d, %d pids live)\n",
						text, ppid, HvKEYS(live_pids_hv));
				break;
			}

			case 'p':
			{
				SV *ppid_sv;
				unsigned int pid = read_int();
				sprintf(text, "%d", pid);
				if (!hv_delete(live_pids_hv, text, strlen(text), 0))
					warn("Inconsistent pids in profile data (pid %d not introduced)", 
								pid);
				if (trace_level)
					warn("End of profile data for pid %s, %d remaining\n", text, 
								HvKEYS(live_pids_hv));
				break;
			}

			case ':':
			{
				char *value, *end;
				SV *value_sv;
				if (NULL == fgets(text, sizeof(text), in))
					croak("Profile format error reading attribute"); /* probably EOF */
				if ((NULL == (value = strchr(text, '=')))
				||  (NULL == (end   = strchr(text, '\n')))
				) {
					warn("attribute malformed '%s'\n", text);
					continue;
				}
				*value++ = '\0';
				value_sv = newSVpvn(value, end-value);
				hv_store(attr_hv, text, strlen(text), value_sv, 0);
				if (trace_level >= 2)
				    warn(": %s = '%s'\n", text, SvPV_nolen(value_sv)); /* includes \n */
				if ('t' == *text && strEQ(text, "ticks_per_sec"))
					ticks_per_sec = SvUV(value_sv);
				break;
			}

			case '#':
				if (NULL == fgets(text, sizeof(text), in))
					croak("Profile format error reading comment"); /* probably EOF */
				if (trace_level >= 2)
				    warn("# %s", text); /* includes \n */
				break;

			default:
				croak("File format error: token %d ('%c'), line %lu", c, c, input_line);
		}
	}

	if (EOF == c && HvKEYS(live_pids_hv)) {
		warn("profile data possibly truncated, no terminator for %d pids", 
					HvKEYS(live_pids_hv));
	}
	sv_free((SV*)live_pids_hv);

	profile_hv = newHV();
	hv_store(profile_hv, "attribute",       9, newRV_noinc((SV*)attr_hv), 0);
	hv_store(profile_hv, "fid_filename",   12, 
						newRV_noinc((SV*)fid_filename_av), 0);
	hv_store(profile_hv, "fid_line_time",  13, 
						newRV_noinc((SV*)fid_line_time_av), 0);
	if (fid_block_time_av)
		hv_store(profile_hv, "fid_block_time", 14, 
							newRV_noinc((SV*)fid_block_time_av), 0);
	if (fid_sub_time_av)
		hv_store(profile_hv, "fid_sub_time",   12, 
							newRV_noinc((SV*)fid_sub_time_av), 0);
	if (sub_fid_lines_hv)
		hv_store(profile_hv, "sub_fid_line",   12, 
							newRV_noinc((SV*)sub_fid_lines_hv), 0);
	if (sub_callers_hv)
		hv_store(profile_hv, "sub_caller",     10, 
							newRV_noinc((SV*)sub_callers_hv), 0);
	return profile_hv;
}

/***********************************
 * Perl XS Code Below Here         *
 ***********************************/

MODULE = Devel::NYTProf		PACKAGE = Devel::NYTProf		
PROTOTYPES: DISABLE

MODULE = Devel::NYTProf		PACKAGE = DB
PROTOTYPES: DISABLE 

void
DB(...)
	CODE:
		DB(aTHX);

void
init_profiler()
	CODE:
		init_profiler(aTHX);

void
_assign_fids();
	CODE:
	/* if we may fork then assign fids to all (currently) known files
	 * to limit the impact of the restriction on assigning fids
	 * after a fork
	 */
	if (forkok)
		write_sub_line_ranges(aTHX, 1);

void
enable_profile(...)
	PPCODE:
		IV prev_DBsingle = SvIV(PL_DBsingle);
		sv_setiv(PL_DBsingle, 1);
		XSRETURN_IV(prev_DBsingle);

void
disable_profile(...)
	PPCODE:
		IV prev_DBsingle = SvIV(PL_DBsingle);
		sv_setiv(PL_DBsingle, 0);
		if (out)
			fflush(out);
		XSRETURN_IV(prev_DBsingle);

void
_finish(...)
	PPCODE:
	if (trace_level)
		warn("_finish pid %d\n", getpid());
	sv_setiv(PL_DBsingle, 0);
	DB(aTHX); /* write data for final statement */
	if (out) {
		write_sub_line_ranges(aTHX, 0);
		write_sub_callers(aTHX);
		if (forkok)
			lock_file();
		fputc('p', out); /* mark end of profile data for this pid */
		output_int(last_pid);
		if (forkok)
			unlock_file();
	}


MODULE = Devel::NYTProf		PACKAGE = Devel::NYTProf::Data
PROTOTYPES: DISABLE 

HV*
load_profile_data_from_file(file=NULL)
	char *file;
	CODE:
	init_runtime(file);

	if (READER_use_stdin) {
		int fd = dup(STDIN_FILENO);
		if (-1 == fd)
			croak("Unable to dup stdin: %s", strerror(errno));
		in = fdopen(fd, "r");
	}
	else if (0 != strlen(READER_input_file)) {
		in = fopen(READER_input_file, "rb");
	}
	else {
		in = fopen(default_file, "rb");
	}
	if (in == NULL) {
		croak("Failed to open input: %s", strerror(errno));
	}
	RETVAL = load_profile_data_from_stream();
	fclose(in);
	OUTPUT:
	RETVAL


