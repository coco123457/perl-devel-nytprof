/* NYTProf.xs
 * vim:ts=2:sw=2
 */
#define PERL_NO_GET_CONTEXT		/* we want efficiency */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#if (PERL_VERSION < 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION < 8))
#ifndef PL_curcop
#define PL_curcop ((cxstack + cxstack_ix)->blk_oldcop)
#endif
#endif

#if !defined(OutCopFILE)
#define OutCopFILE CopFILE
#endif

#include <sys/time.h>
#include <stdio.h>
#ifdef HAS_STDIO_EXT_H
#include <stdio_ext.h>
#else
#warning "Not using stdio_ext.h. Add it to INCLUDE path and recompile with -DHAS_STDIO_EXT_H to use it."
#endif

#ifdef HASFPURGE
#define FPURGE(file) fpurge(file)
#elif defined(HAS_FPURGE)
#define FPURGE(file) _fpurge(file)
#elif defined(HAS__FPURGE)
#define FPURGE(file) __fpurge(file)
#else
#undef FPURGE
#warning "Not using _fpurge() -- There may be a preformance penalty."
#endif

/* Hash table definitions */
#define MAX_HASH_SIZE 512

typedef struct hash_entry {
	unsigned int id;
	void* next_entry;
	char* key;
	unsigned int key_len;
} Hash_entry;

typedef struct hash_table {
	Hash_entry** table;
	unsigned int size;
} Hash_table;

static Hash_table hashtable = {NULL, MAX_HASH_SIZE};
/* END Hash table definitions */

static char error[255];

/* defaults */
static char* default_file = "nytprof.out";
static FILE* out;
static FILE* in;
static pid_t last_pid;
static unsigned int bufsiz = BUFSIZ;
static char* out_buffer;
static bool forkok = 0;
static bool usecputime = 0;
static bool profile_blocks = 1;

/* options and overrides */
static char PROF_output_file[255];
static char READER_input_file[255];
static bool PROF_use_stdout = 0;
static bool READER_use_stdin = 0;
static int trace_level = 0;

/* time tracking */
static struct tms start_ctime, end_ctime;
#ifdef _HAS_GETTIMEOFDAY
static struct timeval start_time, end_time;
#else
static int (*u2time)(pTHX_ UV *) = 0;
static UV start_utime[2], end_utime[2];
#endif
static unsigned int last_executed_line;
static unsigned int last_executed_file;
static unsigned int last_block_line;
static unsigned int last_sub_line;
static bool firstrun = 1;

/* reader module variables */
static HV* profile;
static unsigned int ticks_per_sec = 1;

/* prototypes */
void lock_file();
void unlock_file();
void print_header();
unsigned int get_file_id(char*, STRLEN);
void output_int(unsigned int);
void DB(pTHX);
void set_option(const char*);
void open_file(bool);
void init_runtime();
void init(pTHX);
bool init_reader(const char*);
void DEBUG_print_stats(pTHX);
IV   getTicksPerSec();
HV *load_profile_data_from_file(char*);
AV *store_profile_line_entry(pTHX_ SV *rvav, unsigned int line_num, 
															double time, int count);

/***********************************
 * Devel::NYTProf Functions        *
 ***********************************/

/**
 * Set file lock
 */
void
lock_file() {
	static struct flock lockl = { F_WRLCK, SEEK_SET, 0, 0 };
	fcntl(fileno(out), F_SETLKW, 	&lockl);
}

/**
 * Release file lock
 */
void
unlock_file() {
	fflush(out);
	static struct flock locku = { F_UNLCK, SEEK_SET, 0, 0 };
	fcntl(fileno(out), F_SETLK, 	&locku);
}

/**
 * output file header
 */
void
print_header() {
	unsigned int ticks = 1000000;

	if (forkok) 
		lock_file();

	fputs("# Perl Profile database. Generated by Devel::NYTProf.\n", out);
	/* XXX add $0, time(), $VERSION, datetime, options etc
	 * including, at the start, a 'file format' version (distinct from $VERSION)
	 * all in a standard name-value format that can be parsed
	 * perhaps a subset of JSON.
	 */

	if (usecputime) {
		ticks = CLOCKS_PER_SEC;
	}
	fprintf(out, "# CLOCKS: %u\n", ticks);
	fflush(out);

	if (forkok)
		unlock_file();
}

/**
 * An implementation of the djb2 hash function by Dan Bernstein.
 */
unsigned long
hash (char* _str, unsigned int len) {
	char* str = _str;
	unsigned long hash = 5381;

	while (len--) {
		hash = ((hash << 5) + hash) + *str++; /* hash * 33 + c */
	}
	return hash;
}

/**
 * Fetch/Store on hash table.  entry must always be defined. 
 * hash_op will find hash_entry in the hash table.  
 * hash_entry not in table, insert is false: returns NULL
 * hash_entry not in table, insert is true: inserts hash_entry and returns hash_entry
 * hash_entry in table, insert IGNORED: returns pointer to the actual hash entry
 */
char
hash_op (Hash_entry entry, Hash_entry** retval, bool insert) {
	static int next_fid = 1;	/* 0 is reserved */
	unsigned long h = hash(entry.key, entry.key_len) % hashtable.size;

	Hash_entry* found = hashtable.table[h];
	while(NULL != found) {

		if (found->key_len == entry.key_len && 
				0 == strncmp(found->key, entry.key, entry.key_len)) {
			*retval = found;
			return 0;
		}

		if(NULL == (Hash_entry*)found->next_entry) {
			if (insert) {

				Hash_entry* e = (Hash_entry*)safemalloc(sizeof(Hash_entry));
				e->id = next_fid++;
				e->next_entry = NULL;
				e->key_len = entry.key_len;
				e->key = (char*)safemalloc(sizeof(char) * e->key_len + 1);
				e->key[e->key_len] = '\0';
				strncpy(e->key, entry.key, e->key_len);

				*retval = found->next_entry = e;
				return 1;
			} else {
				*retval = NULL;
				return -1;
			}
		}
		found = (Hash_entry*)found->next_entry;
	}

	if (insert) {
		Hash_entry* e = (Hash_entry*)safemalloc(sizeof(Hash_entry));
		e->id = next_fid++;
		e->next_entry = NULL;
		e->key_len = entry.key_len;
		e->key = (char*)safemalloc(sizeof(char) * e->key_len + 1);
		e->key[e->key_len] = '\0';
		strncpy(e->key, entry.key, e->key_len);

		*retval =	hashtable.table[h] = e;
		return 1;
	}

	retval = NULL;
	return -1;
}

/**
 * Return a unique id number for this file.  Persists across calls.
 */
unsigned int
get_file_id(char* file_name, STRLEN file_name_len) {

	Hash_entry entry, *found;

  /* AutoLoader adds some information to Perl's internal file name that we have
     to remove or else the file path will be borked */
	if (')' == file_name[file_name_len - 1]) {
		char* new_end = strstr(file_name, " (autosplit ");
		if (new_end)
			file_name_len = new_end - file_name;
	}
	entry.key = file_name;
	entry.key_len = file_name_len;

	if(1 == hash_op(entry, &found, 1)) {	/* inserted new entry */
	  /* if this is a synthetic filename for an 'eval'
		 * ie "(eval 42)[/some/filename.pl:line]"
		 * then ensure we've already generated an id for the underlying filename
		 */
		unsigned int eval_fid = 0;
		unsigned int eval_line_num = 0;
		if ('(' == file_name[0] && ']' == file_name[file_name_len-1]) {
			char *start = strchr(file_name, '[');
			char *colon = ":";
			//char *end   = rninstr(file_name, file_name+file_name_len-1, colon, 
			//											colon+1);
			char* end = strchr(file_name + file_name_len, ':');

			if (!start || !end || start > end) {
				warn("Unsupported filename syntax '%s'", file_name);
				return 0;
			}
			++start; /* move past [ */
			eval_fid = get_file_id(start, end - start);	/* recurse */
			eval_line_num = atoi(end+1);
		}

		if (forkok)
			lock_file();

		fputc('@', out);
		output_int(found->id);
		output_int(eval_fid);
		output_int(eval_line_num);
		while (file_name_len--)
			fputc(*file_name++, out);
		fputc('\n', out);

		if (forkok)
			unlock_file();
		if (trace_level)
		  warn("New fid %d: %.*s\n", found->id, found->key_len, found->key);
	}
	else if (trace_level >= 4)
		warn("fid %d: %.*s\n", found->id, found->key_len, found->key);

	return found->id;
}

/**
 * Output an integer in bytes. That is, output the number in binary, using the
 * least number of bytes possible.  All numbers are positive. Use sign slot as
 * a marker
 */
void output_int(unsigned int i) {

	/* general case. handles all integers */
	if (i < 0x80) { /* < 8 bits */
		fputc( (char)i, out);
	}
	else if (i < 0x4000) { /* < 15 bits */
		fputc( (char)((i >> 8) | 0x80), out);
		fputc( (char)i, out);
	}
	else if (i < 0x200000) { /* < 22 bits */
		fputc( (char)((i >> 16) | 0xC0), out);
		fputc( (char)(i >> 8), out);
		fputc( (char)i, out);
	}
	else if (i < 0x10000000)  { /* 32 bits */
		fputc( (char)((i >> 24) | 0xE0), out);
		fputc( (char)(i >> 16), out);
		fputc( (char)(i >> 8), out);
		fputc( (char)i, out);
	}
	else {	/* need all the bytes. */
		fputc( 0xFF, out);
		fputc( (char)(i >> 24), out);
		fputc( (char)(i >> 16), out);
		fputc( (char)(i >> 8), out);
		fputc( (char)i, out);
	}
}


#ifndef DEBUGGING
static char* PL_block_type[] = {
    "NULL",
    "SUB",
    "EVAL",
    "LOOP",
    "SUBST",
    "BLOCK",
};
#endif


/* based on S_dopoptosub_at() from perl pp_ctl.c */
static int
dopopcx_at(pTHX_ PERL_CONTEXT *cxstk, I32 startingblock, UV stop_at)
{
    I32 i;
    register PERL_CONTEXT *cx;
    for (i = startingblock; i >= 0; i--) {
        cx = &cxstk[i];
        UV type_bit = 1 << CxTYPE(cx);
        if (type_bit & stop_at)
            return i;
    }
    return i; /* == -1 */
}


static COP *
start_cop_of_context(pTHX_ PERL_CONTEXT *cx) {
    OP *start_op, *o;
    int type;

    switch (CxTYPE(cx)) {
    case CXt_EVAL:
        start_op = (OP*)cx->blk_oldcop;
        break;
    case CXt_FORMAT:
        start_op = CvSTART(cx->blk_sub.cv);
        break;
    case CXt_SUB:
        start_op = CvSTART(cx->blk_sub.cv);
        break;
    case CXt_LOOP:
#if (PERL_VERSION < 10)
        start_op = cx->blk_loop.redo_op;
#else
        start_op = cx->blk_loop.my_op->op_redoop;
#endif
        break;
    case CXt_BLOCK:
				/* this will be NULL for the top-level 'main' block */
        start_op = (OP*)cx->blk_oldcop;
        break;
    case CXt_SUBST:			/* FALLTHRU */
    case CXt_NULL:			/* FALLTHRU */
		default:
        start_op = NULL;
        break;
    }
    if (!start_op) {
        if (trace_level >= 4)
            warn("\tstart_cop_of_context: can't find start of %s\n", PL_block_type[CxTYPE(cx)]);
        return NULL;
    }
    /* find next cop from OP */
		o = start_op;
    while ( o && (type = (o->op_type) ? o->op_type : o->op_targ) ) {
        if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE) {
				  if (trace_level >= 4)
						warn("\tstart_cop_of_context %s is %s line %d of %s\n",
							PL_block_type[CxTYPE(cx)], OP_NAME(o), CopLINE((COP*)o), OutCopFILE((COP*)o));
					return (COP*)o;
				}
        /* should never get here? */
        if (1 || trace_level)
            warn("\tstart_cop_of_context %s op '%s' isn't a cop", PL_block_type[CxTYPE(cx)], OP_NAME(o));
        if (trace_level >= 4)
            do_op_dump(1, PerlIO_stderr(), o);
        o = o->op_next;
    }
    if (trace_level >= 3) {
			warn("\tstart_cop_of_context: can't find next cop for %s line %d\n",
					PL_block_type[CxTYPE(cx)], CopLINE(PL_curcop));
			do_op_dump(1, PerlIO_stderr(), start_op);
		}
    return NULL;
}

static PERL_CONTEXT *
visit_contexts(pTHX_ UV stop_at, int (*callback)(pTHX_ PERL_CONTEXT *cx, UV *stop_at_ptr)) {
    dSP;
    /* modelled on pp_caller() in pp_ctl.c */
    register I32 cxix = cxstack_ix;
    register PERL_CONTEXT *cx = NULL;
    register PERL_CONTEXT *ccstack = cxstack;
    PERL_SI *top_si = PL_curstackinfo;

    if (trace_level >= 4)
        warn("visit_contexts: \n");

    for (;;) {
        /* we may be in a higher stacklevel, so dig down deeper */
				/* XXX so we'll miss code in sort blocks and signals?		*/
				/* callback should perhaps be moved to dopopcx_at */
        while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {
            if (trace_level >= 3)
							warn("not on main stack (type %d) so digging top_si %p->%p, ccstack %p->%p\n",
                top_si, top_si->si_prev, ccstack, top_si->si_cxstack);
            top_si  = top_si->si_prev;
            ccstack = top_si->si_cxstack;
            cxix = dopopcx_at(aTHX_ ccstack, top_si->si_cxix, stop_at);
        }
        if (cxix < 0 || (cxix == 0 && !top_si->si_prev)) {
						/* cxix==0 && !top_si->si_prev => top-level BLOCK */
						if (trace_level >= 4)
								warn("visit_contexts: reached top of context stack\n");
						return NULL;
        }
        cx = &ccstack[cxix];
        if (trace_level >= 4)
					warn("visit_context: %s cxix %d (si_prev %p)\n",
							PL_block_type[CxTYPE(cx)], cxix, top_si->si_prev);
				if (callback(aTHX_ cx, &stop_at))
					return cx;
        /* no joy, look further */
        cxix = dopopcx_at(aTHX_ ccstack, cxix - 1, stop_at);
    }
    return NULL; /* not reached */
}

int
_check_context(pTHX_ PERL_CONTEXT *cx, UV *stop_at_ptr)
{
		COP *near_cop;

		if (CxTYPE(cx) == CXt_SUB) {
				if (PL_debstash && CvSTASH(cx->blk_sub.cv) == PL_debstash)
					return 0; /* skip subs in DB package */
				if (trace_level >= 4) {
					GV *sv = CvGV(cx->blk_sub.cv);
					warn("\t%s %s\n", PL_block_type[CxTYPE(cx)], (sv) ? GvNAME(sv) : "");
					if (trace_level >= 9)
						sv_dump((SV*)cx->blk_sub.cv);
				}
				near_cop = start_cop_of_context(aTHX_ cx);
				/* don't use the cop if it's in a different file */
				if (OutCopFILE(near_cop) != OutCopFILE(PL_curcop)) {
					return 1; /* stop looking, leave last_sub_line unset */
				}

				last_sub_line = CopLINE(near_cop);
				/* treat sub as a block if we've not found a block yet */
				if (!last_block_line)
						last_block_line = last_sub_line;
				return 1;		/* stop looking */
		}

	/* NULL, EVAL, LOOP, SUBST, BLOCK context */
	if (trace_level >= 4)
		warn("\t%s\n", PL_block_type[CxTYPE(cx)]);
	/* if we've got a block line, skip this context and keep looking for a sub */
	if (last_block_line)
		return 0;
	/* if we can't get a line number for this context, skip it */
	if ((near_cop = start_cop_of_context(aTHX_ cx)) == NULL)
		return 0;
	/* if this context is in a different file... */
	if (OutCopFILE(near_cop) != OutCopFILE(PL_curcop)) {
		/* if we started in a string eval ... */
		if ('(' == *OutCopFILE(PL_curcop)) {
			last_block_line = last_sub_line = 1;
			return 1;
		}
		/* shouldn't happen! */
		if (trace_level >= 3)
			warn("%s in different file (%s, %s)", PL_block_type[CxTYPE(cx)], OutCopFILE(near_cop), OutCopFILE(PL_curcop));
		return 1; /* stop looking */
	}
	last_block_line = CopLINE(near_cop);
	return 0;
}

/**
 * PerlDB implementation. Called before each breakable statement
 */
void
DB(pTHX) {
	IV line;
	char *file;
	unsigned int elapsed;
	COP *cop = PL_curcop;

	if (usecputime) {
		times(&end_ctime);
		elapsed = end_ctime.tms_utime - start_ctime.tms_utime
						+ end_ctime.tms_stime - start_ctime.tms_stime;
	} else {
#ifdef _HAS_GETTIMEOFDAY
		gettimeofday(&end_time, NULL);
		elapsed = (end_time.tv_sec - start_time.tv_sec) * 1000000;
		elapsed += end_time.tv_usec - start_time.tv_usec;
#else
		(*u2time)(aTHX_ end_utime);
		if (end_utime[0] < start_utime[0] + 2000) {
				elapsed = (end_utime[0] - start_utime[0]) * 1000000 + 
										end_utime[1] - start_utime[1];
		}
#endif
	}

	/* out should never be NULL, but perl sometimes falls into DB() AFTER
	   it calls _finish() (which is ONLY used in END {...}. Strange!) */
	if (!out)
		return;

	if (!firstrun) { 
		if (forkok) {
#ifdef FPURGE
			if (last_pid != getpid()) { /* handle forks */
				FPURGE(out);
			}
#endif
			lock_file();
		}

		fputc( (profile_blocks) ? '*' : '+', out);
		output_int(elapsed);
		output_int(last_executed_file);
		output_int(last_executed_line);
    if (profile_blocks) {
			output_int(last_block_line);
			output_int(last_sub_line);
		}
		if (trace_level >= 3)
			warn("Wrote %d:%-4d %2u ticks (%u, %u)\n",
				last_executed_file, last_executed_line, elapsed, last_block_line, 
				last_sub_line);

		if (forkok) {
			unlock_file();
			last_pid = getpid();
		}
	} else {
		firstrun = 0;
	}

	file = OutCopFILE(cop);
	last_executed_file = get_file_id(file, strlen(file));
	last_executed_line = CopLINE(cop);

  if (profile_blocks) {
		if (trace_level >= 4)
			warn("\tlooking for block and sub lines for %u:%u\n", last_executed_file, last_executed_line);
		last_block_line = 0;
		last_sub_line   = 0;
		visit_contexts(aTHX_ ~0, &_check_context);
		/* if we didn't find block or sub scopes then use current line */
		if (!last_block_line) last_block_line = last_executed_line;
		if (!last_sub_line)   last_sub_line   = last_executed_line;
	}

	if (usecputime) {
		times(&start_ctime);
	} else {
#ifdef _HAS_GETTIMEOFDAY
		gettimeofday(&start_time, NULL);
#else
		start_utime[2];
		(*u2time)(aTHX_ start_utime);
#endif
	}
}

/**
 * Sets or toggles the option specified by 'option'. 
 */
void
set_option(const char* option) {
	if(0 == strncmp(option, "use_stdout", 10)) {
		if (trace_level) warn("# Using standard out for output.\n");
		PROF_use_stdout = 1;
	} else if(0 == strncmp(option, "in=", 3)) {
		strncpy(READER_input_file, &option[3], 500);
		if (trace_level) warn("# Using  %s for input.\n", READER_input_file);
	} else if(0 == strncmp(option, "out=", 4)) {
		strncpy(PROF_output_file, &option[4], 500);
		if (trace_level) warn("# Using %s for output.\n", PROF_output_file);
	} else if(0 == strncmp(option, "use_stdin", 9)) {
		if (trace_level) warn("# Using stanard in for input.\n");
		READER_use_stdin = 1;
	} else if(0 == strncmp(option, "allowfork", 9)) {
		if (trace_level) warn("# Fork mode: ENABLED.\n");
		forkok = 1;
	} else if(0 == strncmp(option, "usecputime", 10)) {
		if (trace_level) warn("# Using cpu time.\n");
		usecputime = 1;
	} else if(0 == strncmp(option, "blocks", 6)) {
		if (trace_level) warn("# profiling blocks.\n");
		profile_blocks = 1;
	} else if(0 == strncmp(option, "trace=", 6)) {
		trace_level = atoi(option+6);
		if (trace_level) warn("# trace set to %d.\n", trace_level);
	} else {
		warn("Unknown option: %s\n", option);
	}
}

/**
 * Open the output file. This is encapsulated because the code can be reused
 * without the environment parsing overhead after each fork.
 */
void
open_file(bool forked) {

  char *filename;
	char *mode = (forked) ? "ab" : "wb";
	int fd;
	if (PROF_use_stdout) {										/* output to stdout */
		fd = dup(STDOUT_FILENO);
		if (-1 == fd)
			perror("Unable to dup stdout");
		filename = NULL;
	}
	else if (0 != strlen(PROF_output_file)) {	/* output to user provided file */
		filename = PROF_output_file;
	} else {																	/* output to default output file */
		filename = default_file;
	}
	if (trace_level)
			warn("Opening %s (%s)\n", (filename) ? filename : "STDOUT", mode);
	out = (filename) ? fopen(filename, mode) : fdopen(fd, mode);
}

/************************************
 * Shared Reader,NYTProf Functions  *
 ************************************/

/**
 * Populate runtime values from environment, the running script or use defaults
 */
void
init_runtime(const char* file) {

	/* Runtime configuration
	   Environment vars have lower priority */
	char* sysenv = getenv("NYTPROF");
	if (NULL != sysenv && strlen(sysenv) > 0) {
		char env[500];
		char* result = NULL;

		strcpy(env, sysenv);
		result = strtok(env, ":");

		if (NULL == result) {
			set_option(env);
		}
		while(result != NULL) {
			set_option(result);
			result = strtok(NULL, ":");
		}
	}

	/* a file name passed to load_profile_data_from_file(...) has the highest priority */
	if (NULL != file) {
		READER_use_stdin = 0;
		PROF_use_stdout = 0;
		strncpy(READER_input_file, file, strlen(file));
		strncpy(PROF_output_file, file, strlen(file));
	}
}

/* Initial setup */
void
init(pTHX) {
	HV* hash = get_hv("DB::sub", 0);

	/* Save the process id early. We can monitor it to detect forks that affect 
		 output buffering.
		 NOTE: don't fork before calling the xsloader obviously! */
	last_pid = getpid();

	if (hash == NULL) {
		Perl_croak(aTHX_ "Debug symbols not found. Is perl in debug mode?");
	}

	/* create file id mapping hash */
	hashtable.table = (Hash_entry**)safemalloc(sizeof(Hash_entry*) * hashtable.size);
	memset(hashtable.table, 0, sizeof(Hash_entry*) * hashtable.size);
	
	init_runtime(NULL);

	open_file(0);
	if (out == NULL) {
		Perl_croak(aTHX_ "Failed to open output file\n");
	}

	/*printf("stat block size: %d; os block size %d\n", bufsiz, BUFSIZ);*/
	print_header();

	/* seed first run time */
	if (usecputime) {
		times(&start_ctime);
	} else {
#ifdef _HAS_GETTIMEOFDAY
		gettimeofday(&start_time, NULL);
#else
		SV **svp = hv_fetch(PL_modglobal, "Time::U2time", 12, 0);
		if (!svp || !SvIOK(*svp)) Perl_croak(aTHX_ "Time::HiRes is required");
		u2time = INT2PTR(int(*)(pTHX_ UV*), SvIV(*svp));
		(*u2time)(aTHX_ start_utime);
#endif
	}
}

/************************************
 * Devel::NYTProf::Reader Functions *
 ************************************/

/**
 * reader specific runtime initialization
 */
bool
init_reader(const char* file) {

	init_runtime(file);

	if (READER_use_stdin) {										/* output to stdout */
		int fd = dup(STDIN_FILENO);
		if (-1 == fd) {
			perror("Unable to dup stdin");
		}
		in = fdopen(fd, "r");
	} else if (0 != strlen(READER_input_file)) { /* output to user provided file*/
		in = fopen(READER_input_file, "rb");
	} else {																/* output to default output file */
		in = fopen(default_file, "rb");
	}

	if (in == NULL) {
		return 0;
	}
	return 1;
}

/**
 * prints the stats hash in perl syntax ala data::dumper style 
 */
void
DEBUG_print_stats(pTHX) {
	int numkeys = hv_iterinit(profile);
	/* outer vars */
	SV* line_hv_rv;
	char* filename[255];
	I32 name_len;
	/* inner vars */
	SV* cur_av_rv;
	char* linenum[255];
	I32 linenum_len;

	printf("Stored data for %d keys\n", numkeys);

	printf("$hash = {\n");
	while(NULL != (line_hv_rv = hv_iternextsv(profile, filename, &name_len))) {
		HV* line_hv = (HV*)SvRV(line_hv_rv);
		hv_iterinit(line_hv);
		printf ("  '%s' => {\n", *filename);

		while(NULL != (cur_av_rv = hv_iternextsv(line_hv, linenum, &linenum_len))) {
			AV* cur_av = (AV*)SvRV(cur_av_rv);
			int calls = SvIV(*av_fetch(cur_av, 1, 0));
			float time = SvNV(*av_fetch(cur_av, 0, 0));
			SV** evals_hv_ref = av_fetch(cur_av, 2, 0);
			SV* evals_av_ref;

			printf("    '%s' => [ %f, %d", *linenum, time, calls);

			if (NULL != evals_hv_ref) {
				HV* evals_hv = (HV*)SvRV(*evals_hv_ref);
				char* e_linenum[255];

				printf (", {\n");
				while(NULL != (evals_av_ref = hv_iternextsv(evals_hv, e_linenum,
																										&name_len))) {
					AV* evals_av = (AV*)SvRV(evals_av_ref);
					calls = SvIV(*av_fetch(evals_av, 1, 0));
					time = SvNV(*av_fetch(evals_av, 0, 0));

					printf("                              '%s' => [ %f, %d ],\n", 
									*e_linenum, time, calls);
				}
				printf("                          },\n");
			}
 			printf("           ],\n");
		}
		printf("  },\n");
	}
	printf("};\n");
}

/**
 * Save information about the current line.
 * TODO SLOW! Next on the list for a rewrite.
 */
void
addline(pTHX_ unsigned int line, float time, const char* _file) {

	char* file; /* = (char*)malloc(sizeof(char)*strlen(_file) + 1);*/
	int file_len = 0;
	/* used for evals */
	bool eval_mode = 0;
	int eline = 0;
	float etime = 0;
	/* used in files block */
	SV** file_hv_ref;
	HV* file_hv;
	/* used in lines block */
	char line_str[50];
	SV** line_av_ref;
	AV* line_av;

	if (0 != strncmp(_file, "(eval", 5)) {
		file = (char *)_file;
		file_len = strlen(file);
	}
	else {
		/* its an eval! 'line' is _in_ the eval. File and line number in 'file' */
		char* start = strchr(_file, '[');
		char* end = strrchr(_file, ':');
		if (!start || !end) {
			warn("Ignoring invalid filename syntax '%s'\n", _file);
			return;
		}
		eval_mode = 1;
		file = ++start;
		file_len = end - start;
		/* line number in eval block */
		eline = line;
		/* line number in _file_ */
		line = atoi(end + sizeof(char));
		/* time for this line in the eval block */
		etime = time;
		/* execution time for the file line will be added seperately later */
		time = 0;	
		if (trace_level)
				warn("File: %s, line: %d, time: %f, eval line: %d, eval time: %f\n",
						file, line, time, eline, etime);
	}

	/* AutoLoader adds some information to Perl's internal file name that we have
   to remove or else the file path will be borked */
	if (')' == file[file_len - 1]) {
		char* new_end = strstr(file, " (autosplit ");
		file_len = new_end - file;
	}

	file_hv_ref = hv_fetch(profile, file, file_len, 0);
	
	if (NULL == file_hv_ref) {
		file_hv = newHV();
		hv_store(profile, file, file_len, newRV_noinc((SV*)file_hv), 0);
	} else {
		file_hv = (HV*)SvRV(*file_hv_ref);
	}

	sprintf(line_str, "%u", line);
	line_av_ref = hv_fetch(file_hv, line_str, strlen(line_str), 0);

	if (NULL == line_av_ref) {
		int true_calls = (eval_mode)?0:1;

		line_av = newAV();
		av_store(line_av, 0, newSVnv(time));		/* time */
		av_store(line_av, 1, newSViv(true_calls));				/* calls */
		hv_store(file_hv, line_str, strlen(line_str), newRV_noinc((SV*)line_av), 0);
	} else {
		SV** time_sv_p;
		SV** calls_sv_p;

		line_av = (AV*)SvRV(*line_av_ref);
		time_sv_p = av_fetch(line_av, 0, 0);
		sv_setnv(*time_sv_p, time + SvNVX(*time_sv_p));
		calls_sv_p = av_fetch(line_av, 1, 0);

		if (!eval_mode) {
			sv_inc(*calls_sv_p);
		}
	}

	if (eval_mode) {
		SV** eval_hv_ref = av_fetch(line_av, 2, 0);
		HV* eval_hv;
		SV** eval_av_ref;
		AV* eval_av;

		sprintf(line_str, "%d", eline); /* key */

		if (NULL == eval_hv_ref) {
			eval_hv = newHV();
			av_store(line_av, 2, newRV_noinc((SV*)eval_hv));
		} else {
			eval_hv = (HV*)SvRV(*eval_hv_ref);
		}

		eval_av_ref = hv_fetch(eval_hv, line_str, strlen(line_str), 0);

		if (NULL == eval_av_ref) {
			eval_av = newAV(); /* value */
			av_store(eval_av, 0, newSVnv(etime));
			av_store(eval_av, 1, newSViv(1));
			hv_store(eval_hv, line_str, strlen(line_str), newRV_noinc((SV*)eval_av), 
								0);
		} else {
			SV** time_sv_p;
			SV** calls_sv_p;

			eval_av = (AV*)SvRV(*eval_av_ref);
			time_sv_p = av_fetch(eval_av, 0, 0);
			sv_setnv(*time_sv_p, etime + SvIV(*time_sv_p));
			calls_sv_p = av_fetch(eval_av, 1, 0);
			sv_inc(*calls_sv_p);
		}
	}
}


void
add_entry(pTHX_ AV *dest_av, unsigned int file_num, unsigned int line_num,			
					double time, unsigned int eval_file_num, unsigned int eval_line_num) 
{
	bool eval_mode = eval_file_num;

  /* get ref to array of per-line data */
	SV *line_time_rvav = *av_fetch(dest_av, 
													(eval_line_num) ? eval_file_num : file_num, 1);

	if (!SvROK(line_time_rvav))		/* autoviv */
			sv_setsv(line_time_rvav, newRV_noinc((SV*)newAV()));

  /* times for string evals are accumulated within the line the eval is on */
  if (!eval_line_num) {
		store_profile_line_entry(aTHX_ line_time_rvav, line_num, time, 1);
	}
	else {
		AV *av = store_profile_line_entry(aTHX_ line_time_rvav, eval_line_num,
																			0, 0);
		SV *eval_line_time_rvav = *av_fetch(av, 2, 1);
		if (!SvROK(eval_line_time_rvav))		/* autoviv */
				sv_setsv(eval_line_time_rvav, newRV_noinc((SV*)newAV()));

		store_profile_line_entry(aTHX_ eval_line_time_rvav, line_num, time, 1);
	}
}


AV *
store_profile_line_entry(pTHX_ SV *rvav, unsigned int line_num, double time, 
													int count)
{
	SV *time_rvav = *av_fetch((AV*)SvRV(rvav), line_num, 1);
	AV *line_av;
	if (!SvROK(time_rvav)) {		  /* autoviv */
		line_av = newAV();
		sv_setsv(time_rvav, newRV_noinc((SV*)line_av));
		av_store(line_av, 0, newSVnv(time));
		av_store(line_av, 1, newSViv(count));
	}
  else {
		line_av = (AV*)SvRV(time_rvav);
		SV *time_sv = *av_fetch(line_av, 0, 1);
		sv_setnv(time_sv, time + SvNV(time_sv));
		if (count) {
		  SV *sv = *av_fetch(line_av, 1, 1);
			(count == 1) ? sv_inc(sv) : sv_setiv(sv, time + SvIV(sv));
		}
	}
	return line_av;
}

/**
 * Returns the time that the database was generated.
 * TODO Implement this properly. It was borked due to time constraints
 */
IV
getDatabaseTime() {
	return time(NULL);
}

/**
 * Return the clocks per second as parsed by process(). 1 if not set!
 */
IV
getTicksPerSec() {
	return ticks_per_sec;
}

/**
 * Read an integer, up to 4 bytes stored in binary
 */
unsigned int
read_int() {

	static unsigned char d;
	static unsigned int newint;

	d = fgetc(in);
	if (d < 0x80) { /* 7 bits */
		newint = d;
		return newint;
	}
	else if (d < 0xC0) { /* 14 bits */
		newint = d & 0x7F;
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} 
	else if (d < 0xE0) { /* 21 bits */
		newint = d & 0x1F;
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} 
	else if (d < 0xFF) { /* 28 bits */
		newint = d & 0xF;
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} 
	else if (d == 0xFF) { /* 32 bits */
		newint = (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		newint <<= 8;
		newint |= (unsigned char)fgetc(in);
		return newint;
	} else {
		dTHX;
		Perl_croak(aTHX_ "File format error. Unrecognized marker");
	}
}

/**
 * Process a profile output file and return the results in a hash like
 * { fid_filename  => [ filename, filename, ... ], # index by [fid]
 *   fid_line_time  => [ [...],[...],..  ] # index by [fid][line]
 * }
 * The value of each [fid][line] is an array ref containing:
 * [ number of calls, total time spent ]
 * lines containing string evals also get an extra element
 * [ number of calls, total time spent, [...] ]
 * which is an reference to an array containing the [calls,time]
 * data for each line of the string eval.
 */
HV*
load_profile_data_from_file(char *file) {
	dTHX; 

	unsigned long input_line = 0L;
	unsigned int file_num;
	unsigned int line_num;
	unsigned int ticks;
	char text[MAXPATHLEN*2];
	char c; /* for while loop */
	HV *profile_hv;
	AV* fid_filename_av   = newAV();
	AV* fid_line_time_av  = newAV();
	AV* fid_block_time_av = newAV();
	AV* fid_sub_time_av   = newAV();

	if (! init_reader(file)) {
		Perl_croak(aTHX_ "Failed to open input file\n");
	}

	av_extend(fid_filename_av, 64);  /* grow it up front. */

	while(EOF != (c = fgetc(in))) {
		input_line++;

		switch (c) {
			case '*':			/*FALLTHRU*/
			case '+':
			{
				SV *filename_sv;
				double seconds;
				unsigned int eval_file_num = 0;
				unsigned int eval_line_num = 0;

				ticks    = read_int();
				seconds  = (double)ticks / ticks_per_sec;
				file_num = read_int();
				line_num = read_int();

				filename_sv = *av_fetch(fid_filename_av, file_num, 1);
				if (!SvOK(filename_sv)) {
				  warn("File id %d not defined in file '%s'", file_num, file);
					/* do the best we can */
					sv_setpv(filename_sv, "UNKNOWN");
				  file_num = 0;
				}
				else if (SvROK(filename_sv)) {	/* is an eval */
					AV *av = (AV*)SvRV(filename_sv);
					eval_file_num = SvUV(*av_fetch(av,1,1));
					eval_line_num = SvUV(*av_fetch(av,2,1));
					file_num = eval_file_num;
				}


				add_entry(aTHX_ fid_line_time_av, file_num, line_num,
						seconds, eval_file_num, eval_line_num);
				if (trace_level >= 3)
				    warn("Read %u:%u as %u ticks\n", file_num, line_num, ticks);

				if (c == '*') {
					unsigned int block_line_num = read_int();
					unsigned int sub_line_num   = read_int();

					add_entry(aTHX_ fid_block_time_av, file_num, block_line_num,
							seconds, eval_file_num, eval_line_num);
					add_entry(aTHX_ fid_sub_time_av, file_num, sub_line_num,
							seconds, eval_file_num, eval_line_num);
					if (trace_level >= 3)
							warn("\tblock %u, sub %u\n", block_line_num, sub_line_num);
				}

				break;
			}
			case '@':
			{
				SV *fid_info_sv;
				unsigned int eval_file_num;
				unsigned int eval_line_num;

				file_num = read_int();
				eval_file_num = read_int();
				eval_line_num = read_int();

				if (NULL == fgets(text, sizeof(text)-1, in))
					croak("File format error: '%s' in file declaration'", file);
				if (trace_level)
				    warn("Read new file %.*s as fid %u (eval fid %u line %u)\n",
								strlen(text)-1, text, file_num, eval_file_num, eval_line_num);

				if (av_exists(fid_filename_av, file_num))
					warn("File id %d redefined from %s to %s", file_num,
								SvPV_nolen(AvARRAY(fid_filename_av)[file_num]), text);

				fid_info_sv = newSVpvn(text, strlen(text)-1); /* drop newline */
				if (eval_line_num) {
					/* change fid_info_sv to ref to array of [ name, eval_file_num, eval_line_num ] */
					AV *av = newAV();
					av_store(av, 0, fid_info_sv);
					av_store(av, 1, newSVuv(eval_file_num));
					av_store(av, 2, newSVuv(eval_line_num));
				  fid_info_sv = newRV_noinc((SV*)av);
				}

				av_store(fid_filename_av, file_num, fid_info_sv);
				break;
			}
			case '#':
				if (NULL == fgets(text, 1024, in))
					croak("Error reading '%s' at line %lu", file, input_line);

				if (0 == strncmp(text, " CLOCKS: ", 9)) {
					char* end = &text[strlen(text) - 2];

					ticks_per_sec = strtoul(&text[9], &end, 10);
				}

				if (trace_level >= 2)
				    warn("# %s", text); /* includes \n */
				break;

			default:
				croak("File format error: '%s', line %lu", file, input_line);
		}
	}
	fclose(in);
	if ( 0 && trace_level)
	    DEBUG_print_stats(aTHX);

	profile_hv = newHV();
	hv_store(profile_hv, "fid_filename",   12, newRV_noinc((SV*)fid_filename_av), 0);
	hv_store(profile_hv, "fid_line_time",  13, newRV_noinc((SV*)fid_line_time_av), 0);
	hv_store(profile_hv, "fid_block_time", 14, newRV_noinc((SV*)fid_block_time_av), 0);
	hv_store(profile_hv, "fid_sub_time",   12, newRV_noinc((SV*)fid_sub_time_av), 0);
	return profile_hv;
}

/***********************************
 * Perl XS Code Below Here         *
 ***********************************/

MODULE = Devel::NYTProf		PACKAGE = Devel::NYTProf		
PROTOTYPES: DISABLE

MODULE = Devel::NYTProf		PACKAGE = DB
PROTOTYPES: DISABLE 

void
DB(...)
	CODE:
		DB(aTHX);

void
init()
	CODE:
		init(aTHX);

void
enable_profile(...)
	PPCODE:
		IV prev_DBsingle = SvIV(PL_DBsingle);
		sv_setiv(PL_DBsingle, 1);
		XSRETURN_IV(prev_DBsingle);

void
disable_profile(...)
	PPCODE:
		IV prev_DBsingle = SvIV(PL_DBsingle);
		sv_setiv(PL_DBsingle, 0);
		if (out)
			fflush(out);
		XSRETURN_IV(prev_DBsingle);

void
_finish(...)
	PPCODE:
	if (trace_level)
		warn("_finish pid %d\n", getpid());
	sv_setiv(PL_DBsingle, 0);
	DB(aTHX);
	if (out)
		fflush(out);


MODULE = Devel::NYTProf		PACKAGE = Devel::NYTProf::Reader
PROTOTYPES: DISABLE 

HV*
load_profile_data_from_file(file=NULL)
	char *file;

IV
getDatabaseTime()

IV
getTicksPerSec()
